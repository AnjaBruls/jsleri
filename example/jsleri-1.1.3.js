window["jsleri"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./jsleri.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./jsleri.js":
/*!*******************!*\
  !*** ./jsleri.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global process */\n\n/*\n *  JS-Leri - JavaScript LR-Parsing Module $VERSION$\n *\n *  Another parser module which allows writing the language in plain JavaScript.\n *  This project was inspired by lrparsing (http://lrparsing.sourceforge.net/), a Python\n *  parser written by Russell Stuart, 2014-05-29.\n *\n *  copyright 2015, Jeroen van der Heijden (Transceptor Technology)\n */\n\nvar version = \"1.1.3\" || '';\n\n// dummy function which can be used as alternative for onEnter and onExit methods\nvar noop = function noop() {};\n\nvar RE_LEFT_WHITESPACE = /^\\s+/;\nvar RE_KEYWORDS = /^\\w+/;\nvar RE_WHITESPACE = /\\s+/;\n\nvar isFunction = function isFunction(obj) {\n    return typeof obj === 'function';\n};\n\nvar buildReKeywords = function buildReKeywords(re) {\n    if (typeof re === 'string' && re.indexOf('^', 0) !== 0) {\n        re = '^' + re;\n    }\n    return new RegExp(re);\n};\n\nvar sortOnStrLen = function sortOnStrLen(a, b) {\n    return a.length < b.length;\n};\n\nvar parse = function parse(element, str, tree, reKeywords) {\n    // expecting instance, used for returning feedback when statement is invalid\n    var expecting = new Expecting();\n\n    // used to add a node to the tree\n    var appendTree = function appendTree(tree, node, pos) {\n        if (pos > expecting.pos) {\n            expecting.empty();\n        }\n        node.end = pos;\n        node.str = str.substring(node.start, node.end);\n        tree.push(node);\n    };\n\n    // recursive function to 'walk' through the tree\n    var walk = function walk(element, pos, tree, rule, isRequired) {\n\n        var s, isValid, nodeRes, i, l, reMatch, children, node, mostGreedy;\n\n        s = str.substring(pos).replace(RE_LEFT_WHITESPACE, '');\n\n        node = new Node(element, str.length - s.length);\n\n        expecting.setModeRequired(node.start, isRequired);\n\n        /**************************************************************************\n         * Choice\n         **************************************************************************/\n        if (element instanceof Choice) {\n            mostGreedy = new NodeResult(false, node.start);\n\n            for (i = 0, l = element.elements.length; i < l; i++) {\n                children = [];\n                nodeRes = walk(element.elements[i], node.start, children, rule, true);\n\n                if (nodeRes.isValid && nodeRes.pos > mostGreedy.pos) {\n                    node.children = children;\n                    mostGreedy = nodeRes;\n                }\n            }\n            if (mostGreedy.isValid) appendTree(tree, node, mostGreedy.pos);\n            return mostGreedy;\n        }\n\n        /**************************************************************************\n         * Keyword\n         **************************************************************************/\n        if (element instanceof Keyword) {\n            reMatch = s.match(reKeywords);\n            isValid = element.ignCase ? Boolean(reMatch && reMatch[0].toLowerCase() === element.keyword.toLowerCase()) : Boolean(reMatch && reMatch[0] === element.keyword);\n            if (isValid) appendTree(tree, node, node.start + element.keyword.length);else expecting.update(element, node.start);\n            return new NodeResult(isValid, node.end || node.start);\n        }\n\n        /**************************************************************************\n         * List\n         **************************************************************************/\n        if (element instanceof List) {\n            pos = node.start;\n            for (i = 0, l = 0;;) {\n\n                nodeRes = walk(element.element, pos, node.children, rule, i < element.min);\n                if (!nodeRes.isValid) break;\n                pos = nodeRes.pos;\n                i++;\n\n                nodeRes = walk(element.delimiter, pos, node.children, rule, i < element.min);\n                if (!nodeRes.isValid) break;\n                pos = nodeRes.pos;\n                l++;\n            }\n            isValid = !(i < element.min || element.max && i > element.max || !element.opt && i && i == l);\n            if (isValid) appendTree(tree, node, pos);\n            return new NodeResult(isValid, pos);\n        }\n\n        /**************************************************************************\n         * Optional\n         **************************************************************************/\n        if (element instanceof Optional) {\n            nodeRes = walk(element.element, node.start, node.children, rule, false);\n            if (nodeRes.isValid) appendTree(tree, node, nodeRes.pos);\n            return new NodeResult(true, node.end || node.start);\n        }\n\n        /**************************************************************************\n         * Prio\n         **************************************************************************/\n        if (element instanceof Prio) {\n            if (rule._tested[node.start] === undefined) {\n                rule._tested[node.start] = new NodeResult(false, node.start);\n            }\n            for (i = 0, l = element.elements.length; i < l; i++) {\n                children = [];\n                nodeRes = walk(element.elements[i], node.start, children, rule, true);\n\n                if (nodeRes.isValid && nodeRes.pos > rule._tested[node.start].pos) {\n                    node.children = children;\n                    rule._tested[node.start] = nodeRes;\n                    rule._tree[node.start] = children;\n                }\n            }\n            if (rule._tested[node.start].isValid) appendTree(tree, node, rule._tested[node.start].pos);\n            return rule._tested[node.start];\n        }\n\n        /**************************************************************************\n         * Regex\n         **************************************************************************/\n        if (element instanceof Regex) {\n            reMatch = s.match(element._re);\n            isValid = Boolean(reMatch);\n\n            if (isValid) appendTree(tree, node, node.start + reMatch[0].length);else expecting.update(element, node.start);\n            return new NodeResult(isValid, node.end || node.start);\n        }\n\n        /**************************************************************************\n         * Repeat\n         **************************************************************************/\n        if (element instanceof Repeat) {\n            pos = node.start;\n            for (i = 0; !element.max || i < element.max; i++) {\n                nodeRes = walk(element.element, pos, node.children, rule, i < element.min);\n                if (!nodeRes.isValid) break;\n                pos = nodeRes.pos;\n            }\n            isValid = i >= element.min;\n            if (isValid) appendTree(tree, node, pos);\n            return new NodeResult(isValid, pos);\n        }\n\n        /**************************************************************************\n         * Rule\n         **************************************************************************/\n        if (element instanceof Rule) {\n            element._tested = {};\n            element._tree = {};\n            nodeRes = walk(element.element, node.start, node.children, element, true);\n            if (nodeRes.isValid) appendTree(tree, node, nodeRes.pos);\n            return nodeRes;\n        }\n\n        /**************************************************************************\n         * Sequence\n         **************************************************************************/\n        if (element instanceof Sequence) {\n\n            pos = node.start;\n            for (i = 0, l = element.elements.length; i < l; i++) {\n                nodeRes = walk(element.elements[i], pos, node.children, rule, true);\n                if (nodeRes.isValid) pos = nodeRes.pos;else return nodeRes;\n            }\n            appendTree(tree, node, nodeRes.pos);\n            return nodeRes;\n        }\n\n        /**************************************************************************\n         * Token\n         **************************************************************************/\n        if (element instanceof Token) {\n            isValid = Boolean(s.indexOf(element.token) === 0);\n\n            if (isValid) appendTree(tree, node, node.start + element.token.length);else expecting.update(element, node.start);\n            return new NodeResult(isValid, node.end || node.start);\n        }\n\n        /**************************************************************************\n         * Tokens\n         **************************************************************************/\n        if (element instanceof Tokens) {\n            for (i = 0, l = element.tokens.length; i < l; i++) {\n                if (s.indexOf(element.tokens[i]) === 0) {\n                    appendTree(tree, node, node.start + element.tokens[i].length);\n                    return new NodeResult(true, node.end);\n                }\n            }\n            expecting.update(element, node.start);\n            return new NodeResult(false, node.start);\n        }\n\n        /**************************************************************************\n         * This\n         **************************************************************************/\n        if (element instanceof This) {\n            if (rule._tested[node.start] === undefined) {\n                rule._tested[node.start] = walk(rule.element, node.start, node.children, rule, true);\n                rule._tree[node.start] = node.children;\n            } else {\n                node.children = rule._tree[node.start];\n            }\n            if (rule._tested[node.start].isValid) appendTree(tree, node, rule._tested[node.start].pos);\n            return rule._tested[node.start];\n        }\n    };\n\n    // start walking the tree\n    var nodeRes = walk(element, 0, tree, element, true);\n\n    // get rest if anything\n    var rest = str.substring(nodeRes.pos).replace(RE_LEFT_WHITESPACE, '');\n\n    // set isValid to False if we have 'rest' left.\n    if (nodeRes.isValid && rest) nodeRes.isValid = false;\n\n    // add EndOfStatement to expecting if this is possible\n    if (!expecting.required.length && rest) {\n        expecting.setModeRequired(nodeRes.pos, true);\n        expecting.update(EOS, nodeRes.pos);\n    }\n\n    nodeRes.expecting = expecting.getExpecting();\n\n    // add expecting and correct pos to nodeRes if nodeRes is not valid\n    if (!nodeRes.isValid) nodeRes.pos = expecting.pos;\n\n    // return nodeRes\n    return nodeRes;\n};\n\n/**************************************************************************\n * Choice constructor\n **************************************************************************/\nfunction Choice() {\n    var obj = Jsleri.call(this, Choice, arguments);\n    if (obj) return obj;\n\n    this.elements = this.checkElements(this.args);\n}\nChoice.prototype = Object.create(Jsleri.prototype);\nChoice.prototype.constzructor = Choice;\n\n/**************************************************************************\n * Keyword constructor\n **************************************************************************/\nfunction Keyword(keyword, ignCase) {\n    var obj = Jsleri.call(this, Keyword, arguments);\n    if (obj) return obj;\n\n    keyword = this.args[0];\n    ignCase = this.args[1];\n\n    this.keyword = keyword;\n    this.ignCase = Boolean(ignCase);\n}\nKeyword.prototype = Object.create(Jsleri.prototype);\nKeyword.prototype.constructor = Keyword;\n\n/**************************************************************************\n * List constructor\n **************************************************************************/\nvar List = function List(element, delimiter, _min, _max, opt) {\n    var obj = Jsleri.call(this, List, arguments);\n    if (obj) return obj;\n\n    element = this.args[0];\n    delimiter = this.args[1] === undefined ? new Token(',') : this.args[1];\n\n    _min = this.args[2];\n    _max = this.args[3];\n    opt = this.args[4];\n\n    if (!(element instanceof Jsleri)) throw '(Jsleri-->List) first argument must be an instance of Jsleri; got ' + (typeof element === 'undefined' ? 'undefined' : _typeof(element));\n\n    if (typeof delimiter !== 'string' && !(delimiter instanceof Jsleri)) throw '(Jsleri-->List) second argument must be a string or instance of Jsleri; got ' + (typeof delimiter === 'undefined' ? 'undefined' : _typeof(delimiter));\n\n    this.element = element;\n    this.delimiter = delimiter instanceof Jsleri ? delimiter : new Token(delimiter);\n    this.min = _min === undefined || _min === null ? 0 : _min;\n    this.max = _max === undefined || _max === null ? null : _max;\n\n    // when true the list may end with a delimiter\n    this.opt = Boolean(opt);\n};\nList.prototype = Object.create(Jsleri.prototype);\nList.prototype.constructor = List;\n\n/**************************************************************************\n * Optional constructor\n **************************************************************************/\nfunction Optional(element) {\n    var obj = Jsleri.call(this, Optional, arguments);\n    if (obj) return obj;\n\n    element = this.args[0];\n\n    if (!(element instanceof Jsleri)) throw '(Jsleri-->Optional) first argument must be an instance of Jsleri; got ' + (typeof element === 'undefined' ? 'undefined' : _typeof(element));\n\n    this.element = element;\n}\nOptional.prototype = Object.create(Jsleri.prototype);\nOptional.prototype.constructor = Optional;\n\n/**************************************************************************\n * Prio constructor\n **************************************************************************/\nfunction Prio() {\n    var obj = Jsleri.call(this, Prio, arguments);\n    if (obj) return obj;\n\n    this.elements = this.checkElements(this.args);\n    return new Rule(this);\n}\nPrio.prototype = Object.create(Jsleri.prototype);\nPrio.prototype.constructor = Prio;\n\n/**************************************************************************\n * Regex constructor\n **************************************************************************/\nfunction Regex(re, ignCase) {\n    var obj = Jsleri.call(this, Regex, arguments);\n    if (obj) return obj;\n\n    re = this.args[0];\n    ignCase = this.args[1];\n\n    this.re = re;\n    this._re = new RegExp('^' + re, Boolean(ignCase) ? 'i' : undefined);\n}\nRegex.prototype = Object.create(Jsleri.prototype);\nRegex.prototype.constructor = Regex;\n\n/**************************************************************************\n * Repeat constructor\n **************************************************************************/\nfunction Repeat(element, _min, _max) {\n    var obj = Jsleri.call(this, Repeat, arguments);\n    if (obj) return obj;\n\n    element = this.args[0];\n    _min = this.args[1];\n    _max = this.args[2];\n\n    if (!(element instanceof Jsleri)) throw '(Jsleri-->Repeat) first argument must be an instance of Jsleri; got ' + (typeof element === 'undefined' ? 'undefined' : _typeof(element));\n\n    this.element = element;\n    this.min = _min === undefined || _min === null ? 0 : _min;\n    this.max = _max === undefined || _max === null ? null : _max;\n}\nRepeat.prototype = Object.create(Jsleri.prototype);\nRepeat.prototype.constructor = Repeat;\n\n/**************************************************************************\n * Ref constructor\n **************************************************************************/\nvar refSet = function refSet(element) {\n    if (!(element instanceof Jsleri)) throw '(Jsleri-->Ref-->set) first argument must be an instance of Jsleri; got ' + (typeof element === 'undefined' ? 'undefined' : _typeof(element));\n    Object.assign(this, element);\n};\n\nfunction Ref(Cls) {\n    var Construct = function Construct() {};\n    Construct.prototype = Cls.prototype;\n    var obj = Jsleri.call(this, Construct, arguments);\n    if (obj) {\n        obj.set = refSet;\n        return obj;\n    }\n}\nRef.prototype = Object.create(Jsleri.prototype);\nRef.prototype.constructor = Ref;\n\n/**************************************************************************\n * Grammar constructor\n **************************************************************************/\nfunction Grammar(element, reKeywords) {\n    var obj = Jsleri.call(this, Grammar, arguments);\n    if (obj) return obj;\n\n    element = this.args[0];\n    reKeywords = this.args[1];\n\n    element = element === undefined ? this.constructor.START : element;\n\n    if (!(element instanceof Jsleri)) throw '(Jsleri-->Optional) first argument must be an instance of Jsleri; got ' + (typeof element === 'undefined' ? 'undefined' : _typeof(element));\n\n    this.reKeywords = reKeywords === undefined ? RE_KEYWORDS : buildReKeywords(reKeywords);\n    this.element = element;\n\n    this.parse = function (str) {\n        var tree = new Node(this, 0, str.length, str);\n        var nodeRes = parse(element, str, tree.children, this.reKeywords);\n\n        nodeRes.tree = tree;\n        return nodeRes;\n    };\n}\nGrammar.prototype = Object.create(Jsleri.prototype);\nGrammar.prototype.constructor = Grammar;\n\n/**************************************************************************\n * Rule constructor\n **************************************************************************/\nfunction Rule(element) {\n    var obj = Jsleri.call(this, Rule, arguments);\n    if (obj) return obj;\n\n    element = this.args[0];\n\n    if (!(element instanceof Jsleri)) throw '(Jsleri-->Rule) first argument must be an instance of Jsleri; got ' + (typeof element === 'undefined' ? 'undefined' : _typeof(element));\n\n    this.element = element;\n}\nRule.prototype = Object.create(Jsleri.prototype);\nRule.prototype.constructor = Rule;\n\n/**************************************************************************\n * Sequence constructor\n **************************************************************************/\nfunction Sequence() {\n    var obj = Jsleri.call(this, Sequence, arguments);\n    if (obj) return obj;\n\n    this.elements = this.checkElements(this.args);\n}\nSequence.prototype = Object.create(Jsleri.prototype);\nSequence.prototype.constructor = Sequence;\n\n/**************************************************************************\n * This constructor --> THIS\n **************************************************************************/\nvar This = function This() {\n    if (!(this instanceof This)) return new This();\n};\nThis.prototype = Object.create(Jsleri.prototype);\nThis.prototype.constructor = This;\nvar THIS = new This();\n\n/**************************************************************************\n * Token constructor\n **************************************************************************/\nfunction Token(token) {\n    var obj = Jsleri.call(this, Token, arguments);\n    if (obj) return obj;\n\n    token = this.args[0];\n\n    if (typeof token !== 'string') throw '(Jsleri-->Token) first argument must be a string; got ' + (typeof token === 'undefined' ? 'undefined' : _typeof(token));\n\n    this.token = token;\n}\nToken.prototype = Object.create(Jsleri.prototype);\nToken.prototype.constructor = Token;\n\n/**************************************************************************\n * Tokens constructor\n **************************************************************************/\nfunction Tokens(tokens) {\n    var obj = Jsleri.call(this, Tokens, arguments);\n    if (obj) return obj;\n\n    tokens = this.args[0];\n\n    if (typeof tokens !== 'string') throw '(Jsleri-->Tokens) first argument must be a string; got ' + (typeof tokens === 'undefined' ? 'undefined' : _typeof(tokens));\n\n    this.tokens = tokens.split(RE_WHITESPACE).sort(sortOnStrLen);\n}\nTokens.prototype = Object.create(Jsleri.prototype);\nTokens.prototype.constructor = Tokens;\n\n/**************************************************************************\n * EndOfStatement constructor\n **************************************************************************/\nfunction EndOfStatement() {\n    this.e = 'End of statement';\n}\nEndOfStatement.prototype = Object.create(Jsleri.prototype);\nEndOfStatement.prototype.constructor = EndOfStatement;\nvar EOS = new EndOfStatement();\n\n/**************************************************************************\n * NodeResult constructor\n **************************************************************************/\nfunction NodeResult(isValid, pos) {\n    this.isValid = isValid;\n    this.pos = pos;\n    this.expecting = null;\n}\n\n/**************************************************************************\n * Node constructor\n **************************************************************************/\nfunction Node(element, start, end, str) {\n    this.element = element;\n    this.start = start;\n    this.end = end;\n    this.str = str;\n    this.children = [];\n}\nNode.prototype.walk = function () {\n    this.element.onEnter(this);\n    for (var i = 0, l = this.children.length; i < l; i++) {\n        this.children[i].walk();\n    }\n    this.element.onExit(this);\n};\n\n/**************************************************************************\n * Expecting constructor\n **************************************************************************/\nfunction Expecting() {\n    this.required = [];\n    this.optional = [];\n    this.pos = 0;\n    this._modes = [this.required];\n}\nExpecting.prototype.setModeRequired = function (pos, isRequired) {\n    if (this._modes[pos] !== this.optional) this._modes[pos] = isRequired === false ? this.optional : this.required;\n};\nExpecting.prototype.empty = function () {\n    this.required.length = 0;\n    this.optional.length = 0;\n};\nExpecting.prototype.update = function (element, pos) {\n    if (pos > this.pos) {\n        this.empty();\n        this.pos = pos;\n    }\n    if (pos === this.pos && this._modes[pos].indexOf(element) === -1) this._modes[pos].push(element);\n};\nExpecting.prototype.getExpecting = function () {\n    return this.required.concat(this.optional);\n};\n\n/***************************************************************************\n * Jsleri constructor\n *\n * All 'other' objects inherit from Jsleri\n ***************************************************************************/\nfunction Jsleri(Cls, args) {\n    args = Array.prototype.slice.call(args);\n\n    if (!(this instanceof Cls)) return new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n\n    this.setCallbacks(args);\n    this.args = args;\n}\nJsleri.prototype.setCallbacks = function (args) {\n    var first = args[0];\n\n    if (first === undefined || first === null || typeof first === 'string' || first instanceof Jsleri) return;\n\n    if (isFunction(first.onEnter)) this.onEnter = first.onEnter;\n\n    if (isFunction(first.onExit)) this.onExit = first.onExit;\n\n    args.splice(0, 1);\n};\nJsleri.prototype.onEnter = noop;\nJsleri.prototype.onExit = noop;\nJsleri.prototype.checkElements = function (a) {\n    var i = 0,\n        l = a.length;\n    if (l === 0) throw '(Jsleri-->' + this.constructor.name + ') Need at least one Jsleri argument';\n    for (; i < l; i++) {\n        if (!(a[i] instanceof Jsleri)) {\n            a[i] = new Token(a[i]);\n        }\n    }return a;\n};\nJsleri.prototype.checkElement = function (a) {\n    if (!(a instanceof Jsleri)) {\n        a = new Token(a);\n    }\n    return a;\n};\n\nexports.version = version;\nexports.noop = noop;\nexports.Keyword = Keyword;\nexports.Regex = Regex;\nexports.Token = Token;\nexports.Tokens = Tokens;\nexports.Sequence = Sequence;\nexports.Choice = Choice;\nexports.Repeat = Repeat;\nexports.List = List;\nexports.Optional = Optional;\nexports.Ref = Ref;\nexports.Prio = Prio;\nexports.THIS = THIS;\nexports.Grammar = Grammar;\nexports.EOS = EOS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qc2xlcmkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc2xlcmkvanNsZXJpLmpzPzE1ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHByb2Nlc3MgKi9cblxuLypcbiAqICBKUy1MZXJpIC0gSmF2YVNjcmlwdCBMUi1QYXJzaW5nIE1vZHVsZSAkVkVSU0lPTiRcbiAqXG4gKiAgQW5vdGhlciBwYXJzZXIgbW9kdWxlIHdoaWNoIGFsbG93cyB3cml0aW5nIHRoZSBsYW5ndWFnZSBpbiBwbGFpbiBKYXZhU2NyaXB0LlxuICogIFRoaXMgcHJvamVjdCB3YXMgaW5zcGlyZWQgYnkgbHJwYXJzaW5nIChodHRwOi8vbHJwYXJzaW5nLnNvdXJjZWZvcmdlLm5ldC8pLCBhIFB5dGhvblxuICogIHBhcnNlciB3cml0dGVuIGJ5IFJ1c3NlbGwgU3R1YXJ0LCAyMDE0LTA1LTI5LlxuICpcbiAqICBjb3B5cmlnaHQgMjAxNSwgSmVyb2VuIHZhbiBkZXIgSGVpamRlbiAoVHJhbnNjZXB0b3IgVGVjaG5vbG9neSlcbiAqL1xuXG52YXIgdmVyc2lvbiA9IHByb2Nlc3MuZW52LlZFUlNJT04gfHwgJyc7XG5cbi8vIGR1bW15IGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGFsdGVybmF0aXZlIGZvciBvbkVudGVyIGFuZCBvbkV4aXQgbWV0aG9kc1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIFJFX0xFRlRfV0hJVEVTUEFDRSA9IC9eXFxzKy87XG52YXIgUkVfS0VZV09SRFMgPSAvXlxcdysvO1xudmFyIFJFX1dISVRFU1BBQ0UgPSAvXFxzKy87XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGJ1aWxkUmVLZXl3b3JkcyA9IGZ1bmN0aW9uIChyZSkge1xuICAgIGlmICh0eXBlb2YgcmUgPT09ICdzdHJpbmcnICYmIHJlLmluZGV4T2YoJ14nLCAwKSAhPT0gMCkge1xuICAgICAgICByZSA9ICdeJyArIHJlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZSk7XG59O1xuXG52YXIgc29ydE9uU3RyTGVuID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPCBiLmxlbmd0aDtcbn07XG5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHIsIHRyZWUsIHJlS2V5d29yZHMpIHtcbiAgICAvLyBleHBlY3RpbmcgaW5zdGFuY2UsIHVzZWQgZm9yIHJldHVybmluZyBmZWVkYmFjayB3aGVuIHN0YXRlbWVudCBpcyBpbnZhbGlkXG4gICAgdmFyIGV4cGVjdGluZyA9IG5ldyBFeHBlY3RpbmcoKTtcblxuICAgIC8vIHVzZWQgdG8gYWRkIGEgbm9kZSB0byB0aGUgdHJlZVxuICAgIHZhciBhcHBlbmRUcmVlID0gZnVuY3Rpb24gKHRyZWUsIG5vZGUsIHBvcykge1xuICAgICAgICBpZiAocG9zID4gZXhwZWN0aW5nLnBvcykge1xuICAgICAgICAgICAgZXhwZWN0aW5nLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5lbmQgPSBwb3M7XG4gICAgICAgIG5vZGUuc3RyID0gc3RyLnN1YnN0cmluZyhub2RlLnN0YXJ0LCBub2RlLmVuZCk7XG4gICAgICAgIHRyZWUucHVzaChub2RlKTtcbiAgICB9O1xuXG4gICAgLy8gcmVjdXJzaXZlIGZ1bmN0aW9uIHRvICd3YWxrJyB0aHJvdWdoIHRoZSB0cmVlXG4gICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoZWxlbWVudCwgcG9zLCB0cmVlLCBydWxlLCBpc1JlcXVpcmVkKSB7XG5cbiAgICAgICAgdmFyIHMsXG4gICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgbm9kZVJlcyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgcmVNYXRjaCxcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG1vc3RHcmVlZHk7XG5cbiAgICAgICAgcyA9IHN0ci5zdWJzdHJpbmcocG9zKS5yZXBsYWNlKFJFX0xFRlRfV0hJVEVTUEFDRSwgJycpO1xuXG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZShlbGVtZW50LCBzdHIubGVuZ3RoIC0gcy5sZW5ndGgpO1xuXG4gICAgICAgIGV4cGVjdGluZy5zZXRNb2RlUmVxdWlyZWQobm9kZS5zdGFydCwgaXNSZXF1aXJlZCk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIENob2ljZVxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQ2hvaWNlKSB7XG4gICAgICAgICAgICBtb3N0R3JlZWR5ID0gbmV3IE5vZGVSZXN1bHQoZmFsc2UsIG5vZGUuc3RhcnQpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWxlbWVudC5lbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgIG5vZGVSZXMgPSB3YWxrKGVsZW1lbnQuZWxlbWVudHNbaV0sIG5vZGUuc3RhcnQsIGNoaWxkcmVuLCBydWxlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlUmVzLmlzVmFsaWQgJiYgbm9kZVJlcy5wb3MgPiBtb3N0R3JlZWR5LnBvcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIG1vc3RHcmVlZHkgPSBub2RlUmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3N0R3JlZWR5LmlzVmFsaWQpXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJlZSh0cmVlLCBub2RlLCBtb3N0R3JlZWR5LnBvcyk7XG4gICAgICAgICAgICByZXR1cm4gbW9zdEdyZWVkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBLZXl3b3JkXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBLZXl3b3JkKSB7XG4gICAgICAgICAgICByZU1hdGNoID0gcy5tYXRjaChyZUtleXdvcmRzKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBlbGVtZW50LmlnbkNhc2UgP1xuICAgICAgICAgICAgICAgIEJvb2xlYW4oIHJlTWF0Y2ggJiYgcmVNYXRjaFswXS50b0xvd2VyQ2FzZSgpID09PSBlbGVtZW50LmtleXdvcmQudG9Mb3dlckNhc2UoKSApIDpcbiAgICAgICAgICAgICAgICBCb29sZWFuKCByZU1hdGNoICYmIHJlTWF0Y2hbMF0gPT09IGVsZW1lbnQua2V5d29yZCApO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQpXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJlZSh0cmVlLCBub2RlLCBub2RlLnN0YXJ0ICsgZWxlbWVudC5rZXl3b3JkLmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZXhwZWN0aW5nLnVwZGF0ZShlbGVtZW50LCBub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVJlc3VsdChpc1ZhbGlkLCBub2RlLmVuZCB8fCBub2RlLnN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBMaXN0XG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBMaXN0KSB7XG4gICAgICAgICAgICBwb3MgPSBub2RlLnN0YXJ0O1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IDA7Oykge1xuXG4gICAgICAgICAgICAgICAgbm9kZVJlcyA9IHdhbGsoZWxlbWVudC5lbGVtZW50LCBwb3MsIG5vZGUuY2hpbGRyZW4sIHJ1bGUsIGkgPCBlbGVtZW50Lm1pbik7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVzLmlzVmFsaWQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IG5vZGVSZXMucG9zO1xuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICAgIG5vZGVSZXMgPSB3YWxrKGVsZW1lbnQuZGVsaW1pdGVyLCBwb3MsIG5vZGUuY2hpbGRyZW4sIHJ1bGUsIGkgPCBlbGVtZW50Lm1pbik7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVzLmlzVmFsaWQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IG5vZGVSZXMucG9zO1xuICAgICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzVmFsaWQgPSAoIShpIDwgZWxlbWVudC5taW4gfHwgKGVsZW1lbnQubWF4ICYmIGkgPiBlbGVtZW50Lm1heCkgfHwgKCFlbGVtZW50Lm9wdCAmJiBpICYmIGkgPT0gbCkpKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKVxuICAgICAgICAgICAgICAgIGFwcGVuZFRyZWUodHJlZSwgbm9kZSwgcG9zKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVJlc3VsdChpc1ZhbGlkLCBwb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIE9wdGlvbmFsXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBPcHRpb25hbCkge1xuICAgICAgICAgICAgbm9kZVJlcyA9IHdhbGsoZWxlbWVudC5lbGVtZW50LCBub2RlLnN0YXJ0LCBub2RlLmNoaWxkcmVuLCBydWxlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAobm9kZVJlcy5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgIGFwcGVuZFRyZWUodHJlZSwgbm9kZSwgbm9kZVJlcy5wb3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmVzdWx0KHRydWUsIG5vZGUuZW5kIHx8IG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFByaW9cbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFByaW8pIHtcbiAgICAgICAgICAgIGlmIChydWxlLl90ZXN0ZWRbbm9kZS5zdGFydF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJ1bGUuX3Rlc3RlZFtub2RlLnN0YXJ0XSA9IG5ldyBOb2RlUmVzdWx0KGZhbHNlLCBub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBlbGVtZW50LmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgbm9kZVJlcyA9IHdhbGsoZWxlbWVudC5lbGVtZW50c1tpXSwgbm9kZS5zdGFydCwgY2hpbGRyZW4sIHJ1bGUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVSZXMuaXNWYWxpZCAmJiBub2RlUmVzLnBvcyA+IHJ1bGUuX3Rlc3RlZFtub2RlLnN0YXJ0XS5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBydWxlLl90ZXN0ZWRbbm9kZS5zdGFydF0gPSBub2RlUmVzO1xuICAgICAgICAgICAgICAgICAgICBydWxlLl90cmVlW25vZGUuc3RhcnRdID0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bGUuX3Rlc3RlZFtub2RlLnN0YXJ0XS5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgIGFwcGVuZFRyZWUodHJlZSwgbm9kZSwgcnVsZS5fdGVzdGVkW25vZGUuc3RhcnRdLnBvcyk7XG4gICAgICAgICAgICByZXR1cm4gcnVsZS5fdGVzdGVkW25vZGUuc3RhcnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFJlZ2V4XG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBSZWdleCkge1xuICAgICAgICAgICAgcmVNYXRjaCA9IHMubWF0Y2goZWxlbWVudC5fcmUpO1xuICAgICAgICAgICAgaXNWYWxpZCA9IEJvb2xlYW4ocmVNYXRjaCk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKVxuICAgICAgICAgICAgICAgIGFwcGVuZFRyZWUodHJlZSwgbm9kZSwgbm9kZS5zdGFydCArIHJlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBleHBlY3RpbmcudXBkYXRlKGVsZW1lbnQsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmVzdWx0KGlzVmFsaWQsIG5vZGUuZW5kIHx8IG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFJlcGVhdFxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgUmVwZWF0KSB7XG4gICAgICAgICAgICBwb3MgPSBub2RlLnN0YXJ0O1xuICAgICAgICAgICAgZm9yIChpID0gMDshZWxlbWVudC5tYXggfHwgaSA8IGVsZW1lbnQubWF4O2krKykge1xuICAgICAgICAgICAgICAgIG5vZGVSZXMgPSB3YWxrKGVsZW1lbnQuZWxlbWVudCwgcG9zLCBub2RlLmNoaWxkcmVuLCBydWxlLCBpIDwgZWxlbWVudC5taW4pO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlcy5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBub2RlUmVzLnBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzVmFsaWQgPSAoaSA+PSBlbGVtZW50Lm1pbik7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZClcbiAgICAgICAgICAgICAgICBhcHBlbmRUcmVlKHRyZWUsIG5vZGUsIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSZXN1bHQoaXNWYWxpZCwgcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBSdWxlXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBSdWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50Ll90ZXN0ZWQgPSB7fTtcbiAgICAgICAgICAgIGVsZW1lbnQuX3RyZWUgPSB7fTtcbiAgICAgICAgICAgIG5vZGVSZXMgPSB3YWxrKGVsZW1lbnQuZWxlbWVudCwgbm9kZS5zdGFydCwgbm9kZS5jaGlsZHJlbiwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobm9kZVJlcy5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgIGFwcGVuZFRyZWUodHJlZSwgbm9kZSwgbm9kZVJlcy5wb3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVSZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogU2VxdWVuY2VcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNlcXVlbmNlKSB7XG5cbiAgICAgICAgICAgIHBvcyA9IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWxlbWVudC5lbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2RlUmVzID0gd2FsayhlbGVtZW50LmVsZW1lbnRzW2ldLCBwb3MsIG5vZGUuY2hpbGRyZW4sIHJ1bGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlUmVzLmlzVmFsaWQpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5vZGVSZXMucG9zO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcHBlbmRUcmVlKHRyZWUsIG5vZGUsIG5vZGVSZXMucG9zKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlUmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFRva2VuXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgaXNWYWxpZCA9IEJvb2xlYW4ocy5pbmRleE9mKGVsZW1lbnQudG9rZW4pID09PSAwKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQpXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJlZSh0cmVlLCBub2RlLCBub2RlLnN0YXJ0ICsgZWxlbWVudC50b2tlbi5sZW5ndGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGV4cGVjdGluZy51cGRhdGUoZWxlbWVudCwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSZXN1bHQoaXNWYWxpZCwgbm9kZS5lbmQgfHwgbm9kZS5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogVG9rZW5zXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBUb2tlbnMpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBlbGVtZW50LnRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocy5pbmRleE9mKGVsZW1lbnQudG9rZW5zW2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUcmVlKHRyZWUsIG5vZGUsIG5vZGUuc3RhcnQgKyBlbGVtZW50LnRva2Vuc1tpXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSZXN1bHQodHJ1ZSwgbm9kZS5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdGluZy51cGRhdGUoZWxlbWVudCwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSZXN1bHQoZmFsc2UsIG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFRoaXNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFRoaXMpIHtcbiAgICAgICAgICAgIGlmIChydWxlLl90ZXN0ZWRbbm9kZS5zdGFydF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJ1bGUuX3Rlc3RlZFtub2RlLnN0YXJ0XSA9IHdhbGsocnVsZS5lbGVtZW50LCBub2RlLnN0YXJ0LCBub2RlLmNoaWxkcmVuLCBydWxlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBydWxlLl90cmVlW25vZGUuc3RhcnRdID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IHJ1bGUuX3RyZWVbbm9kZS5zdGFydF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZS5fdGVzdGVkW25vZGUuc3RhcnRdLmlzVmFsaWQpXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJlZSh0cmVlLCBub2RlLCBydWxlLl90ZXN0ZWRbbm9kZS5zdGFydF0ucG9zKTtcbiAgICAgICAgICAgIHJldHVybiBydWxlLl90ZXN0ZWRbbm9kZS5zdGFydF07XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBzdGFydCB3YWxraW5nIHRoZSB0cmVlXG4gICAgdmFyIG5vZGVSZXMgPSB3YWxrKGVsZW1lbnQsIDAsIHRyZWUsIGVsZW1lbnQsIHRydWUpO1xuXG4gICAgLy8gZ2V0IHJlc3QgaWYgYW55dGhpbmdcbiAgICB2YXIgcmVzdCA9IHN0ci5zdWJzdHJpbmcobm9kZVJlcy5wb3MpLnJlcGxhY2UoUkVfTEVGVF9XSElURVNQQUNFLCAnJyk7XG5cbiAgICAvLyBzZXQgaXNWYWxpZCB0byBGYWxzZSBpZiB3ZSBoYXZlICdyZXN0JyBsZWZ0LlxuICAgIGlmIChub2RlUmVzLmlzVmFsaWQgJiYgcmVzdCkgbm9kZVJlcy5pc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAvLyBhZGQgRW5kT2ZTdGF0ZW1lbnQgdG8gZXhwZWN0aW5nIGlmIHRoaXMgaXMgcG9zc2libGVcbiAgICBpZiAoIWV4cGVjdGluZy5yZXF1aXJlZC5sZW5ndGggJiYgcmVzdCkge1xuICAgICAgICBleHBlY3Rpbmcuc2V0TW9kZVJlcXVpcmVkKG5vZGVSZXMucG9zLCB0cnVlKTtcbiAgICAgICAgZXhwZWN0aW5nLnVwZGF0ZShFT1MsIG5vZGVSZXMucG9zKTtcbiAgICB9XG5cbiAgICBub2RlUmVzLmV4cGVjdGluZyA9IGV4cGVjdGluZy5nZXRFeHBlY3RpbmcoKTtcblxuICAgIC8vIGFkZCBleHBlY3RpbmcgYW5kIGNvcnJlY3QgcG9zIHRvIG5vZGVSZXMgaWYgbm9kZVJlcyBpcyBub3QgdmFsaWRcbiAgICBpZiAoIW5vZGVSZXMuaXNWYWxpZClcbiAgICAgICAgbm9kZVJlcy5wb3MgPSBleHBlY3RpbmcucG9zO1xuXG4gICAgLy8gcmV0dXJuIG5vZGVSZXNcbiAgICByZXR1cm4gbm9kZVJlcztcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ2hvaWNlIGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5mdW5jdGlvbiBDaG9pY2UgKCkge1xuICAgIHZhciBvYmogPSBKc2xlcmkuY2FsbCh0aGlzLCBDaG9pY2UsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG9iaikgcmV0dXJuIG9iajtcblxuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmNoZWNrRWxlbWVudHModGhpcy5hcmdzKTtcbn1cbkNob2ljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuQ2hvaWNlLnByb3RvdHlwZS5jb25zdHpydWN0b3IgPSBDaG9pY2U7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogS2V5d29yZCBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gS2V5d29yZCAoa2V5d29yZCwgaWduQ2FzZSkge1xuICAgIHZhciBvYmogPSBKc2xlcmkuY2FsbCh0aGlzLCBLZXl3b3JkLCBhcmd1bWVudHMpO1xuICAgIGlmIChvYmopIHJldHVybiBvYmo7XG5cbiAgICBrZXl3b3JkID0gdGhpcy5hcmdzWzBdO1xuICAgIGlnbkNhc2UgPSB0aGlzLmFyZ3NbMV07XG5cbiAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgIHRoaXMuaWduQ2FzZSA9IEJvb2xlYW4oaWduQ2FzZSk7XG59XG5LZXl3b3JkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSnNsZXJpLnByb3RvdHlwZSk7XG5LZXl3b3JkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleXdvcmQ7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTGlzdCBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIExpc3QgPSBmdW5jdGlvbiBMaXN0IChlbGVtZW50LCBkZWxpbWl0ZXIsIF9taW4sIF9tYXgsIG9wdCkge1xuICAgIHZhciBvYmogPSBKc2xlcmkuY2FsbCh0aGlzLCBMaXN0LCBhcmd1bWVudHMpO1xuICAgIGlmIChvYmopIHJldHVybiBvYmo7XG5cbiAgICBlbGVtZW50ID0gdGhpcy5hcmdzWzBdO1xuICAgIGRlbGltaXRlciA9ICh0aGlzLmFyZ3NbMV0gPT09IHVuZGVmaW5lZCkgPyBuZXcgVG9rZW4oJywnKSA6IHRoaXMuYXJnc1sxXTtcblxuICAgIF9taW4gPSB0aGlzLmFyZ3NbMl07XG4gICAgX21heCA9IHRoaXMuYXJnc1szXTtcbiAgICBvcHQgPSB0aGlzLmFyZ3NbNF07XG5cbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSnNsZXJpKSlcbiAgICAgICAgdGhyb3cgJyhKc2xlcmktLT5MaXN0KSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEpzbGVyaTsgZ290ICcgKyB0eXBlb2YgZWxlbWVudDtcblxuICAgIGlmICh0eXBlb2YgZGVsaW1pdGVyICE9PSAnc3RyaW5nJyAmJiAhKGRlbGltaXRlciBpbnN0YW5jZW9mIEpzbGVyaSkpXG4gICAgICAgIHRocm93ICcoSnNsZXJpLS0+TGlzdCkgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgb3IgaW5zdGFuY2Ugb2YgSnNsZXJpOyBnb3QgJyArIHR5cGVvZiBkZWxpbWl0ZXI7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuZGVsaW1pdGVyID0gKGRlbGltaXRlciBpbnN0YW5jZW9mIEpzbGVyaSkgPyBkZWxpbWl0ZXIgOiBuZXcgVG9rZW4oZGVsaW1pdGVyKTtcbiAgICB0aGlzLm1pbiA9IChfbWluID09PSB1bmRlZmluZWQgfHwgX21pbiA9PT0gbnVsbCkgPyAwIDogX21pbjtcbiAgICB0aGlzLm1heCA9IChfbWF4ID09PSB1bmRlZmluZWQgfHwgX21heCA9PT0gbnVsbCkgPyBudWxsIDogX21heDtcblxuICAgIC8vIHdoZW4gdHJ1ZSB0aGUgbGlzdCBtYXkgZW5kIHdpdGggYSBkZWxpbWl0ZXJcbiAgICB0aGlzLm9wdCA9IEJvb2xlYW4gKG9wdCk7XG59O1xuTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaXN0O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE9wdGlvbmFsIGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5mdW5jdGlvbiBPcHRpb25hbCAoZWxlbWVudCkge1xuICAgIHZhciBvYmogPSBKc2xlcmkuY2FsbCh0aGlzLCBPcHRpb25hbCwgYXJndW1lbnRzKTtcbiAgICBpZiAob2JqKSByZXR1cm4gb2JqO1xuXG4gICAgZWxlbWVudCA9IHRoaXMuYXJnc1swXTtcblxuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBKc2xlcmkpKVxuICAgICAgICB0aHJvdyAnKEpzbGVyaS0tPk9wdGlvbmFsKSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEpzbGVyaTsgZ290ICcgKyB0eXBlb2YgZWxlbWVudDtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5PcHRpb25hbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuT3B0aW9uYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3B0aW9uYWw7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUHJpbyBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gUHJpbyAoKSB7XG4gICAgdmFyIG9iaiA9IEpzbGVyaS5jYWxsKHRoaXMsIFByaW8sIGFyZ3VtZW50cyk7XG4gICAgaWYgKG9iaikgcmV0dXJuIG9iajtcblxuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmNoZWNrRWxlbWVudHModGhpcy5hcmdzKTtcbiAgICByZXR1cm4gKG5ldyBSdWxlKHRoaXMpKTtcbn1cblByaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShKc2xlcmkucHJvdG90eXBlKTtcblByaW8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJpbztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSZWdleCBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gUmVnZXggKHJlLCBpZ25DYXNlKSB7XG4gICAgdmFyIG9iaiA9IEpzbGVyaS5jYWxsKHRoaXMsIFJlZ2V4LCBhcmd1bWVudHMpO1xuICAgIGlmIChvYmopIHJldHVybiBvYmo7XG5cbiAgICByZSA9IHRoaXMuYXJnc1swXTtcbiAgICBpZ25DYXNlID0gdGhpcy5hcmdzWzFdO1xuXG4gICAgdGhpcy5yZSA9IHJlO1xuICAgIHRoaXMuX3JlID0gbmV3IFJlZ0V4cCgnXicgKyByZSwgQm9vbGVhbihpZ25DYXNlKSA/ICdpJyA6IHVuZGVmaW5lZCk7XG59XG5SZWdleC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuUmVnZXgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVnZXg7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmVwZWF0IGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5mdW5jdGlvbiBSZXBlYXQgKGVsZW1lbnQsIF9taW4sIF9tYXgpIHtcbiAgICB2YXIgb2JqID0gSnNsZXJpLmNhbGwodGhpcywgUmVwZWF0LCBhcmd1bWVudHMpO1xuICAgIGlmIChvYmopIHJldHVybiBvYmo7XG5cbiAgICBlbGVtZW50ID0gdGhpcy5hcmdzWzBdO1xuICAgIF9taW4gPSB0aGlzLmFyZ3NbMV07XG4gICAgX21heCA9IHRoaXMuYXJnc1syXTtcblxuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBKc2xlcmkpKVxuICAgICAgICB0aHJvdyAnKEpzbGVyaS0tPlJlcGVhdCkgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBKc2xlcmk7IGdvdCAnICsgdHlwZW9mIGVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMubWluID0gKF9taW4gPT09IHVuZGVmaW5lZCB8fCBfbWluID09PSBudWxsKSA/IDAgOiBfbWluO1xuICAgIHRoaXMubWF4ID0gKF9tYXggPT09IHVuZGVmaW5lZCB8fCBfbWF4ID09PSBudWxsKSA/IG51bGwgOiBfbWF4O1xufVxuUmVwZWF0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSnNsZXJpLnByb3RvdHlwZSk7XG5SZXBlYXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwZWF0O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJlZiBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIHJlZlNldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEpzbGVyaSkpXG4gICAgICAgIHRocm93ICcoSnNsZXJpLS0+UmVmLS0+c2V0KSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEpzbGVyaTsgZ290ICcgKyB0eXBlb2YgZWxlbWVudDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGVsZW1lbnQpO1xufVxuXG5cbmZ1bmN0aW9uIFJlZiAoQ2xzKSB7XG4gICAgdmFyIENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIENvbnN0cnVjdC5wcm90b3R5cGUgPSBDbHMucHJvdG90eXBlO1xuICAgIHZhciBvYmogPSBKc2xlcmkuY2FsbCh0aGlzLCBDb25zdHJ1Y3QsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG9iaikge1xuICAgICAgICBvYmouc2V0ID0gcmVmU2V0O1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn1cblJlZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuUmVmLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlZjtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBHcmFtbWFyIGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5mdW5jdGlvbiBHcmFtbWFyIChlbGVtZW50LCByZUtleXdvcmRzKSB7XG4gICAgdmFyIG9iaiA9IEpzbGVyaS5jYWxsKHRoaXMsIEdyYW1tYXIsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG9iaikgcmV0dXJuIG9iajtcblxuICAgIGVsZW1lbnQgPSB0aGlzLmFyZ3NbMF07XG4gICAgcmVLZXl3b3JkcyA9IHRoaXMuYXJnc1sxXTtcblxuICAgIGVsZW1lbnQgPSAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuY29uc3RydWN0b3IuU1RBUlQgOiBlbGVtZW50O1xuXG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEpzbGVyaSkpXG4gICAgICAgIHRocm93ICcoSnNsZXJpLS0+T3B0aW9uYWwpIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSnNsZXJpOyBnb3QgJyArIHR5cGVvZiBlbGVtZW50O1xuXG4gICAgdGhpcy5yZUtleXdvcmRzID0gKHJlS2V5d29yZHMgPT09IHVuZGVmaW5lZCkgPyBSRV9LRVlXT1JEUyA6IGJ1aWxkUmVLZXl3b3JkcyhyZUtleXdvcmRzKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgTm9kZSh0aGlzLCAwLCBzdHIubGVuZ3RoLCBzdHIpO1xuICAgICAgICB2YXIgbm9kZVJlcyA9IHBhcnNlKFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHN0cixcbiAgICAgICAgICAgIHRyZWUuY2hpbGRyZW4sXG4gICAgICAgICAgICB0aGlzLnJlS2V5d29yZHNcbiAgICAgICAgKTtcblxuICAgICAgICBub2RlUmVzLnRyZWUgPSB0cmVlO1xuICAgICAgICByZXR1cm4gbm9kZVJlcztcbiAgICB9O1xufVxuR3JhbW1hci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuR3JhbW1hci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmFtbWFyO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJ1bGUgY29uc3RydWN0b3JcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmZ1bmN0aW9uIFJ1bGUgKGVsZW1lbnQpIHtcbiAgICB2YXIgb2JqID0gSnNsZXJpLmNhbGwodGhpcywgUnVsZSwgYXJndW1lbnRzKTtcbiAgICBpZiAob2JqKSByZXR1cm4gb2JqO1xuXG4gICAgZWxlbWVudCA9IHRoaXMuYXJnc1swXTtcblxuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBKc2xlcmkpKVxuICAgICAgICB0aHJvdyAnKEpzbGVyaS0tPlJ1bGUpIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSnNsZXJpOyBnb3QgJyArIHR5cGVvZiBlbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbn1cblJ1bGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShKc2xlcmkucHJvdG90eXBlKTtcblJ1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUnVsZTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTZXF1ZW5jZSBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gU2VxdWVuY2UgKCkge1xuICAgIHZhciBvYmogPSBKc2xlcmkuY2FsbCh0aGlzLCBTZXF1ZW5jZSwgYXJndW1lbnRzKTtcbiAgICBpZiAob2JqKSByZXR1cm4gb2JqO1xuXG4gICAgdGhpcy5lbGVtZW50cyA9IHRoaXMuY2hlY2tFbGVtZW50cyh0aGlzLmFyZ3MpO1xufVxuU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShKc2xlcmkucHJvdG90eXBlKTtcblNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlcXVlbmNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoaXMgY29uc3RydWN0b3IgLS0+IFRISVNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBUaGlzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaGlzKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKCk7XG59O1xuVGhpcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuVGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaGlzO1xudmFyIFRISVMgPSBuZXcgVGhpcygpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRva2VuIGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5mdW5jdGlvbiBUb2tlbiAodG9rZW4pIHtcbiAgICB2YXIgb2JqID0gSnNsZXJpLmNhbGwodGhpcywgVG9rZW4sIGFyZ3VtZW50cyk7XG4gICAgaWYgKG9iaikgcmV0dXJuIG9iajtcblxuICAgIHRva2VuID0gdGhpcy5hcmdzWzBdO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93ICcoSnNsZXJpLS0+VG9rZW4pIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmc7IGdvdCAnICsgdHlwZW9mIHRva2VuO1xuXG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xufVxuVG9rZW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShKc2xlcmkucHJvdG90eXBlKTtcblRva2VuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRva2VuO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRva2VucyBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gVG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgb2JqID0gSnNsZXJpLmNhbGwodGhpcywgVG9rZW5zLCBhcmd1bWVudHMpO1xuICAgIGlmIChvYmopIHJldHVybiBvYmo7XG5cbiAgICB0b2tlbnMgPSB0aGlzLmFyZ3NbMF07XG5cbiAgICBpZiAodHlwZW9mIHRva2VucyAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93ICcoSnNsZXJpLS0+VG9rZW5zKSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nOyBnb3QgJyArIHR5cGVvZiB0b2tlbnM7XG5cbiAgICB0aGlzLnRva2VucyA9IHRva2Vucy5zcGxpdChSRV9XSElURVNQQUNFKS5zb3J0KHNvcnRPblN0ckxlbik7XG59XG5Ub2tlbnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShKc2xlcmkucHJvdG90eXBlKTtcblRva2Vucy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb2tlbnM7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRW5kT2ZTdGF0ZW1lbnQgY29uc3RydWN0b3JcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmZ1bmN0aW9uIEVuZE9mU3RhdGVtZW50ICgpIHtcbiAgICB0aGlzLmUgPSAnRW5kIG9mIHN0YXRlbWVudCc7XG59XG5FbmRPZlN0YXRlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzbGVyaS5wcm90b3R5cGUpO1xuRW5kT2ZTdGF0ZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW5kT2ZTdGF0ZW1lbnQ7XG52YXIgRU9TID0gbmV3IEVuZE9mU3RhdGVtZW50KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTm9kZVJlc3VsdCBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gTm9kZVJlc3VsdCAoaXNWYWxpZCwgcG9zKSB7XG4gICAgdGhpcy5pc1ZhbGlkID0gaXNWYWxpZDtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmV4cGVjdGluZyA9IG51bGw7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTm9kZSBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gTm9kZSAoZWxlbWVudCwgc3RhcnQsIGVuZCwgc3RyKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xufVxuTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQub25FbnRlcih0aGlzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGsoKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50Lm9uRXhpdCh0aGlzKTtcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwZWN0aW5nIGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5mdW5jdGlvbiBFeHBlY3RpbmcgKCkge1xuICAgIHRoaXMucmVxdWlyZWQgPSBbXTtcbiAgICB0aGlzLm9wdGlvbmFsID0gW107XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuX21vZGVzID0gW3RoaXMucmVxdWlyZWRdO1xufVxuRXhwZWN0aW5nLnByb3RvdHlwZS5zZXRNb2RlUmVxdWlyZWQgPSBmdW5jdGlvbiAocG9zLCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKHRoaXMuX21vZGVzW3Bvc10gIT09IHRoaXMub3B0aW9uYWwpXG4gICAgICAgIHRoaXMuX21vZGVzW3Bvc10gPSAoaXNSZXF1aXJlZCA9PT0gZmFsc2UpID8gdGhpcy5vcHRpb25hbCA6IHRoaXMucmVxdWlyZWQ7XG59O1xuRXhwZWN0aW5nLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlcXVpcmVkLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5vcHRpb25hbC5sZW5ndGggPSAwO1xufTtcbkV4cGVjdGluZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvcykge1xuICAgIGlmIChwb3MgPiB0aGlzLnBvcykge1xuICAgICAgICB0aGlzLmVtcHR5KCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBpZiAocG9zID09PSB0aGlzLnBvcyAmJiB0aGlzLl9tb2Rlc1twb3NdLmluZGV4T2YoZWxlbWVudCkgPT09IC0xKVxuICAgICAgICB0aGlzLl9tb2Rlc1twb3NdLnB1c2goZWxlbWVudCk7XG59O1xuRXhwZWN0aW5nLnByb3RvdHlwZS5nZXRFeHBlY3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZWQuY29uY2F0KHRoaXMub3B0aW9uYWwpO1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogSnNsZXJpIGNvbnN0cnVjdG9yXG4gKlxuICogQWxsICdvdGhlcicgb2JqZWN0cyBpbmhlcml0IGZyb20gSnNsZXJpXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gSnNsZXJpIChDbHMsIGFyZ3MpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xzKSlcbiAgICAgICAgcmV0dXJuIG5ldyAoQ2xzLmJpbmQuYXBwbHkoQ2xzLCBbQ2xzXS5jb25jYXQoYXJncykpKSgpO1xuXG4gICAgdGhpcy5zZXRDYWxsYmFja3MoYXJncyk7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn1cbkpzbGVyaS5wcm90b3R5cGUuc2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZmlyc3QgPSBhcmdzWzBdO1xuXG4gICAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZmlyc3QgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBmaXJzdCBpbnN0YW5jZW9mIEpzbGVyaSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZmlyc3Qub25FbnRlcikpXG4gICAgICAgIHRoaXMub25FbnRlciA9IGZpcnN0Lm9uRW50ZXI7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihmaXJzdC5vbkV4aXQpKVxuICAgICAgICB0aGlzLm9uRXhpdCA9IGZpcnN0Lm9uRXhpdDtcblxuICAgIGFyZ3Muc3BsaWNlKDAsIDEpO1xufTtcbkpzbGVyaS5wcm90b3R5cGUub25FbnRlciA9IG5vb3A7XG5Kc2xlcmkucHJvdG90eXBlLm9uRXhpdCA9IG5vb3A7XG5Kc2xlcmkucHJvdG90eXBlLmNoZWNrRWxlbWVudHMgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBpID0gMCwgbCA9IGEubGVuZ3RoO1xuICAgIGlmIChsID09PSAwKVxuICAgICAgICB0aHJvdyAnKEpzbGVyaS0tPicgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnKSBOZWVkIGF0IGxlYXN0IG9uZSBKc2xlcmkgYXJndW1lbnQnO1xuICAgIGZvciAoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIShhW2ldIGluc3RhbmNlb2YgSnNsZXJpKSkge1xuICAgICAgICAgICAgYVtpXSA9IG5ldyBUb2tlbihhW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBhO1xufTtcbkpzbGVyaS5wcm90b3R5cGUuY2hlY2tFbGVtZW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgSnNsZXJpKSkge1xuICAgICAgICBhID0gbmV3IFRva2VuKGEpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbmV4cG9ydCB7XG4gICAgdmVyc2lvbixcbiAgICBub29wLFxuICAgIEtleXdvcmQsXG4gICAgUmVnZXgsXG4gICAgVG9rZW4sXG4gICAgVG9rZW5zLFxuICAgIFNlcXVlbmNlLFxuICAgIENob2ljZSxcbiAgICBSZXBlYXQsXG4gICAgTGlzdCxcbiAgICBPcHRpb25hbCxcbiAgICBSZWYsXG4gICAgUHJpbyxcbiAgICBUSElTLFxuICAgIEdyYW1tYXIsXG4gICAgRU9TXG59OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./jsleri.js\n");

/***/ })

/******/ });